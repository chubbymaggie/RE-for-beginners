\section{\StructurePackingSectionName}
\label{structure_packing}

\RU{Достаточно немаловажный момент, это упаковка полей в структурах\footnote{См. также: \URLWPDA}.}
\EN{One important thing is fields packing in structures\footnote{See also: \URLWPDA}.}

\RU{Возьмем простой пример:}\EN{Let's take a simple example:}

\lstinputlisting{patterns/15_structs/4_packing/packing.c}

\RU{Как видно, мы имеем два поля \Tchar (занимающий один байт) и еще два ~--- \Tint (по 4 байта).}
\EN{As we see, we have two \Tchar fields (each is exactly one byte) and two more~---\Tint (each --- 4 bytes).}

% subsections:

\input{patterns/15_structs/4_packing/x86}

\ifdefined\IncludeARM
\input{patterns/15_structs/4_packing/ARM}
\fi
\ifdefined\IncludeMIPS
\input{patterns/15_structs/4_packing/MIPS}
\fi

\subsection{\RU{Еще кое-что}\EN{One more word}}

\EN{Passing a structure as a function argument (instead of a passing pointer to structure) is the same
as passing all structure fields one by one.}
\RU{Передача структуры как аргумент функции (вместо передачи указателя на структуру) это то же
что и передача всех полей структуры по одному.}
\EN{If the structure fields are packed by default, the f() function can be rewritten as:}
\RU{Если поля в структуре пакуются по умолчанию, то функцию f() можно переписать так:}

\begin{lstlisting}
void f(char a, int b, char c, int d)
{
    printf ("a=%d; b=%d; c=%d; d=%d\n", a, b, c, d);
};
\end{lstlisting}

\RU{И в итоге будет такой же код}\EN{And that leads to the same code}.
