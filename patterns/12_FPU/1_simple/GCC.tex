\ifdefined\IncludeGCC
\subsubsection{GCC}

\RU{GCC 4.4.1 (с опцией \Othree) генерирует похожий код, хотя и с некоторой разницей:}
\EN{GCC 4.4.1 (with \Othree option) emits the same code, just slightly different:}

\lstinputlisting[caption=\Optimizing GCC 4.4.1]{patterns/12_FPU/1_simple/GCC.asm.\LANG}

\RU{Разница в том, что в стек сначала заталкивается 3,14 (в \ST{0}), а затем значение 
из \TT{arg\_0} делится на то, что лежит в регистре \ST{0}.}
\EN{The difference is that, first of all, 3.14 is pushed to the stack (into \ST{0}), and then the value 
in \TT{arg\_0} is divided by the value in \ST{0}.}

\index{x86!\Instructions!FDIVR}
\RU{\FDIVR означает \IT{Reverse Divide}~--- делить, поменяв делитель и делимое местами. 
Точно такой же инструкции для умножения нет, потому что она была бы бессмысленна (ведь умножение 
операция коммутативная), так что остается только \FMUL без соответствующей ей \TT{-R} инструкции.}
\EN{\FDIVR stands for \IT{Reverse Divide}~---to divide with divisor and dividend swapped with each other. 
There is no likewise instruction for multiplication since it is 
a commutative operation, so we just have \FMUL without its \TT{-R} counterpart.}

\index{x86!\Instructions!FADDP}
\RU{\FADDP не только складывает два значения, но также и выталкивает из стека одно значение. 
После этого в \ST{0} остается только результат сложения.}
\EN{\FADDP adds the two values but also pops one value from the stack. 
After that operation, \ST{0} holds the sum.}
\fi
