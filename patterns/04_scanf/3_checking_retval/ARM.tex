\subsection{ARM}

\subsubsection{ARM: \OptimizingKeilVI (\ThumbMode)}

\lstinputlisting[caption=\OptimizingKeilVI (\ThumbMode)]{patterns/04_scanf/3_checking_retval/ex3_ARM_Keil_thumb_O3.asm}

\index{ARM!\Instructions!CMP}
\index{ARM!\Instructions!BEQ}
\RU{Здесь для нас есть новые инструкции: \CMP и \ac{BEQ}.}
\EN{The new instructions here are \CMP and \ac{BEQ}.}

\CMP \RU{аналогична той что в x86: она отнимает один аргумент от второго и сохраняет флаги.}
\EN{is analogous to the x86 instruction with the same name, it subtracts one of the arguments from the other and updates the conditional flags if needed.}
% TODO: в мануале ARM $op1 + NOT(op2) + 1$ вместо вычитания

\index{ARM!\Registers!Z}
\index{x86!\Instructions!JZ}
\ac{BEQ} \RU{совершает переход по другому адресу, 
если операнды при сравнении были равны, 
либо если результат последнего вычисления был 0, либо если флаг Z равен 1.}
\EN{jumps to another address if the operands were equal to each other, or,
if the result of the last computation was 0, or if the Z flag is 1.}
\RU{То же что и \JZ в}\EN{It behaves as \JZ in} x86.

\RU{Всё остальное просто: исполнение разветвляется на две ветки, затем они сходятся там, 
где в \Reg{0} записывается 0 как возвращаемое из функции значение и происходит выход из функции.}
\EN{Everything else is simple: the execution flow forks in two branches, then the branches
converge at the point
where 0 is written into the \Reg{0} as a function return value, and then the function ends.}

\subsubsection{ARM64}

\lstinputlisting[caption=\NonOptimizing GCC 4.9.1 ARM64,numbers=left]{patterns/04_scanf/3_checking_retval/ARM64_GCC491_O0.s.\LANG}

\index{ARM!\Instructions!CMP}
\index{ARM!\Instructions!Bcc}
\EN{Code flow in this case forks with the use of CMP/BNE (Branch if Not Equal) instructions pair.}
\RU{Исполнение здесь разветвляется, используя пару инструкций CMP/BNE (Branch if Not Equal: переход если не равно).}
