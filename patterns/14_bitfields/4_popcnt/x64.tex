\subsection{x64}
\label{subsec:popcnt}

\RU{Немного изменим пример, расширив его до 64-х бит}\EN{Let's modify the example slightly to extend it to 64-bit}:

\lstinputlisting[label=popcnt_x64_example]{patterns/14_bitfields/4_popcnt/shifts64.c}

\ifdefined\IncludeGCC
\subsubsection{\NonOptimizing GCC 4.8.2}

\RU{Пока всё просто}\EN{So far so easy}.

\lstinputlisting[caption=\NonOptimizing GCC 4.8.2]{patterns/14_bitfields/4_popcnt/shifts64_GCC_O0.s.\LANG}

\subsubsection{\Optimizing GCC 4.8.2}

\lstinputlisting[caption=\Optimizing GCC 4.8.2,numbers=left,label=shifts64_GCC_O3]{patterns/14_bitfields/4_popcnt/shifts64_GCC_O3.s.\LANG}

\RU{Код более лаконичный, но содержит одну необычную вещь}\EN{This code is terser, but has a quirk}.
\RU{Во всех примерах, что мы пока видели, инкремент значения переменной \q{rt} происходит после сравнения 
определенного бита с единицей, но здесь \q{rt} увеличивается на 1 до этого (строка 6), записывая новое значение
в регистр \EDX.}
\EN{In all examples that we see so far, we were incrementing the \q{rt} value after comparing a specific bit,
but the code here increments \q{rt} before (line 6), writing the new value into register \EDX .}
\RU{Затем, если последний бит был 1, инструкция}\EN{Thus, if the last bit is 1, the} \CMOVNE%
\footnote{Conditional MOVe if Not Equal\RU{ (\MOV если не равно)}}\EN{ instruction}
(\RU{которая синонимична}\EN{which is a synonym for} \CMOVNZ%
\footnote{Conditional MOVe if Not Zero\RU{ (\MOV если не ноль)}}) \IT{\RU{фиксирует}\EN{commits}} 
\RU{новое значение}\EN{the new value of} \q{rt}
\RU{копируя значение из}\EN{by moving} \EDX (\q{\RU{предполагаемое значение rt}\EN{proposed rt value}}) 
\RU{в}\EN{into} \EAX 
(\q{\RU{текущее}\EN{current} rt} \RU{которое будет возвращено в конце функции}\EN{to be returned at the end}).
\RU{Следовательно, инкремент происходит на каждом шаге цикла, т.е. 64 раза, вне всякой связи с входным
значением.}
\EN{Hence, the incrementing is done at each step of loop, i.e., 64 times, without any relation to the input value.}

\RU{Преимущество этого кода в том, что он содержит только один условный переход (в конце цикла) вместо
двух (пропускающий инкремент \q{rt} и ещё одного в конце цикла).}
\EN{The advantage of this code is that it contain only one conditional jump (at the end of the loop) instead of 
two jumps (skipping the \q{rt} value increment and at the end of loop).}
\RU{И это может работать быстрее на современных CPU с предсказателем переходов}%
\EN{And that might work faster on the modern CPUs with branch predictors}: \myref{branch_predictors}.

\label{FATRET}
\index{x86!\Instructions!FATRET}
\RU{Последняя инструкция это}\EN{The last instruction is} \INS{REP RET} (\EN{opcode}\RU{опкод} \TT{F3 C3}) 
\RU{которая также называется}\EN{which is also called} \INS{FATRET} \RU{в}\EN{by} MSVC.
\RU{Это оптимизированная версия \RET, рекомендуемая AMD для вставки в конце функции, если \RET идет
сразу после условного перехода}\EN{This is somewhat optimized version of \RET, 
which is recommended by AMD to be placed at the end of function, if \RET goes right after conditional jump}: 
\cite[p.15]{AMDOptimization}
\footnote{\RU{Больше об этом}\EN{More information on it}: \url{http://go.yurichev.com/17328}}.
\fi

\subsubsection{\Optimizing MSVC 2010}

\lstinputlisting[caption=MSVC 2010]{patterns/14_bitfields/4_popcnt/MSVC_2010_x64_Ox.asm.\LANG}

\index{x86!\Instructions!ROL}
\RU{Здесь используется инструкция}\EN{Here the} \ROL \RU{вместо}\EN{instruction is used instead of} 
\SHL, \RU{которая на самом деле}\EN{which is in fact} \q{rotate left}\RU{ (прокручивать влево)} 
\RU{вместо}\EN{instead of} \q{shift left}\RU{ (сдвиг влево)},
\RU{но здесь, в этом примере, она работает так же как и}
\EN{but in this example it works just as} \TT{SHL}.

\ifx\LITE\undefined
\RU{Об этих \q{прокручивающих} инструкциях больше читайте здесь}\EN{You can read more about the rotate instruction 
here}: \myref{ROL_ROR}.
\fi

\Reg{8} \RU{здесь считает от 64 до 0}\EN{here is counting from 64 to 0}. 
\RU{Это как бы инвертированная переменная $i$}\EN{It's just like an inverted $i$}.

\RU{Вот таблица некоторых регистров в процессе исполнения}\EN{Here is a table of some registers during the execution}:

\begin{center}
\begin{tabular}{ | l | l | }
\hline
\cellcolor{blue!25} RDX & \cellcolor{blue!25} R8 \\
\hline
0x0000000000000001 & 64 \\
\hline
0x0000000000000002 & 63 \\
\hline
0x0000000000000004 & 62 \\
\hline
0x0000000000000008 & 61 \\
\hline
... & ... \\
\hline
0x4000000000000000 & 2 \\
\hline
0x8000000000000000 & 1 \\
\hline
\end{tabular}
\end{center}

\ifx\LITE\undefined
\index{x86!\Instructions!FATRET}
\RU{В конце видим инструкцию}\EN{At the end we see the} \INS{FATRET}\RU{, которая была описана здесь}\EN{ instruction, 
which was explained here}: \myref{FATRET}.
\fi

\subsubsection{\Optimizing MSVC 2012}

\lstinputlisting[caption=MSVC 2012]{patterns/14_bitfields/4_popcnt/MSVC_2012_x64_Ox.asm.\LANG}

\index{\CompilerAnomaly}
\label{MSVC2012_anomaly}
\Optimizing MSVC 2012 \RU{делает почти то же самое что и оптимизирующий}\EN{does almost the same job as 
optimizing} MSVC 2010, \RU{но почему-то он генерирует 2 идентичных тела цикла и счетчик цикла теперь 32
вместо 64}\EN{but somehow, it generates two identical loop bodies and the loop count is now 32 instead of 64}.
\RU{Честно говоря, нельзя сказать, почему. Какой-то трюк с оптимизацией? Может быть, телу цикла лучше быть
немного длиннее?}
\EN{To be honest, it's not possible to say why. Some optimization trick? Maybe it's better for the loop body to be slightly 
longer?}
\RU{Так или иначе, такой код здесь уместен, чтобы показать, что результат компилятора
иногда может быть очень странный и нелогичный, но прекрасно работающий, конечно же.}
\EN{Anyway, such code is relevant here to show that sometimes the compiler output may be really weird and 
illogical, but perfectly working.}
