\subsection{ARM + \OptimizingKeilVI (\ARMMode)}

\begin{lstlisting}[caption=\OptimizingKeilVI (\ARMMode)]
02 0C C0 E3          BIC     R0, R0, #0x200
01 09 80 E3          ORR     R0, R0, #0x4000
1E FF 2F E1          BX      LR
\end{lstlisting}

\index{ARM!\Instructions!BIC}
\INS{BIC} (\IT{BItwise bit Clear}) \RU{это инструкция сбрасывающая заданные биты. 
Это как аналог \AND, но только с инвертированным операндом.}\EN{is an instruction for clearing 
specific bits. This is just like the \AND instruction, but with inverted operand.}
\EN{I.e., it's analogous to a \NOT+\AND instruction pair.}
\RU{Т.е. это аналог инструкций \NOT+\AND.}

\index{ARM!\Instructions!ORR}
\INS{ORR} \RU{это \q{логическое или}, аналог}\EN{is \q{logical or}, analogous to} \OR \InENRU x86.

\RU{Пока всё понятно}\EN{So far it's easy}.

\subsection{ARM + \OptimizingKeilVI (\ThumbMode)}

\begin{lstlisting}[caption=\OptimizingKeilVI (\ThumbMode)]
01 21 89 03          MOVS    R1, 0x4000
08 43                ORRS    R0, R1
49 11                ASRS    R1, R1, #5   ; generate 0x200 and place to R1
88 43                BICS    R0, R1
70 47                BX      LR
\end{lstlisting}

\RU{Вероятно, Keil решил, что код в режиме Thumb,}
\EN{Seems like Keil decided that the code in Thumb mode,}
\RU{получающий}\EN{making} \TT{0x200} \RU{из}\EN{from} \TT{0x4000}, 
\RU{более компактный, нежели код,}\EN{is more compact than the code} 
\RU{записывающий}\EN{for writing} \TT{0x200} \RU{в какой-нибудь регистр}\EN{to an arbitrary register}.
% TODO1 пример, как компилятор при помощи сдвигов оптизирует такое: a=0x1000; b=0x2000; c=0x4000, etc

\index{ARM!\Instructions!ASRS}
\RU{Поэтому при помощи инструкции}
\EN{So that is why, with the help of} \INS{ASRS} 
(\ASRdesc), \RU{это значение вычисляется как}\EN{this value is calculated as} $\TT{0x4000} \gg 5$.

\subsection{ARM + \OptimizingXcodeIV (\ARMMode)}
\label{anomaly:LLVM}
\index{\CompilerAnomaly}

\begin{lstlisting}[caption=\OptimizingXcodeIV (\ARMMode),label=ARM_leaf_example3]
42 0C C0 E3          BIC             R0, R0, #0x4200
01 09 80 E3          ORR             R0, R0, #0x4000
1E FF 2F E1          BX              LR
\end{lstlisting}

\RU{Код, который был сгенерирован LLVM, в исходном коде, на самом деле, выглядел бы так:}
\EN{The code that was generated by LLVM, in source code form could be something like this:}

\begin{lstlisting}
    REMOVE_BIT (rt, 0x4200);
    SET_BIT (rt, 0x4000);
\end{lstlisting}

\RU{И он делает в точности что нам нужно}\EN{And it does exactly what we need}. 
\RU{Но почему}\EN{But why} \TT{0x4200}? 
\RU{Возможно, это артефакт оптимизатора LLVM}%
\EN{Perhaps, that an artifact from LLVM's optimizer}%
\footnote{\RU{Это был}\EN{It was} LLVM build 2410.2.00 \RU{входящий в состав}\EN{bundled with} Apple Xcode 4.6.3}.
\RU{Возможно, ошибка оптимизатора компилятора, но создаваемый код всё же работает верно.}
\EN{Probably a compiler's optimizer error, but the generated code works correctly anyway.}

\RU{Об аномалиях компиляторов, подробнее читайте здесь}
\EN{You can read more about compiler anomalies here}~(\myref{anomaly:Intel}).

\OptimizingXcodeIV \RU{для режима Thumb генерирует точно такой же код.}
\EN{for Thumb mode generates the same code.}

\subsection{ARM: \RU{ещё об инструкции \INS{BIC}}\EN{more about the \INS{BIC} instruction}}
\index{ARM!\Instructions!BIC}

\RU{Если немного переделать пример}\EN{Let's rework the example slightly}:

\begin{lstlisting}
int f(int a)
{
    int rt=a;

    REMOVE_BIT (rt, 0x1234);

    return rt;
};
\end{lstlisting}

\EN{Then the optimizing}\RU{То оптимизирующий} Keil 5.03 
\RU{в режиме ARM сделает такое}\EN{in ARM mode does}:

\begin{lstlisting}
f PROC
        BIC      r0,r0,#0x1000
        BIC      r0,r0,#0x234
        BX       lr
        ENDP
\end{lstlisting}

\EN{There are two \INS{BIC} instructions, i.e., bits \TT{0x1234} are cleared in two passes.}
\RU{Здесь две инструкции \INS{BIC}, т.е. биты \TT{0x1234} сбрасываются в два прохода.}
\EN{This is because it's not possible to encode \TT{0x1234} in a \INS{BIC} instruction, 
but it's possible to encode \TT{0x1000} and \TT{0x234}.}
\RU{Это потому что в инструкции \INS{BIC} нельзя закодировать значение \TT{0x1234}, 
но можно закодировать \TT{0x1000} либо \TT{0x234}.}

\subsection{ARM64: \Optimizing GCC (Linaro) 4.9}

\Optimizing GCC\RU{, компилирующий для ARM64, может использовать \AND вместо}\EN{compiling for ARM64 can use 
the \AND instruction instead of} \INS{BIC}:

\begin{lstlisting}[caption=\Optimizing GCC (Linaro) 4.9]
f:
	and	w0, w0, -513	; 0xFFFFFFFFFFFFFDFF
	orr	w0, w0, 16384	; 0x4000
	ret
\end{lstlisting}

\subsection{ARM64: \NonOptimizing GCC (Linaro) 4.9}

\NonOptimizing GCC \RU{генерирует больше избыточного кода, но он работает также}\EN{generates more redundant 
code, but works just like optimized}:

\begin{lstlisting}[caption=\NonOptimizing GCC (Linaro) 4.9]
f:
	sub	sp, sp, #32
	str	w0, [sp,12]
	ldr	w0, [sp,12]
	str	w0, [sp,28]
	ldr	w0, [sp,28]
	orr	w0, w0, 16384	; 0x4000
	str	w0, [sp,28]
	ldr	w0, [sp,28]
	and	w0, w0, -513	; 0xFFFFFFFFFFFFFDFF
	str	w0, [sp,28]
	ldr	w0, [sp,28]
	add	sp, sp, 32
	ret
\end{lstlisting}
