\section{ostream}
\index{\Cpp!ostream}

\RU{Начнем снова с примера типа \q{hello world}, на этот раз используя ostream:}
\EN{Let's start again with a \q{hello world} example, but now we are going to use ostream:}

\lstinputlisting{\CURPATH/ostream/1.cpp}

\RU{Из практически любого учебника \Cpp, известно, что операцию << можно заменить для других типов.}
\EN{Almost any \Cpp textbook tells us that the \TT{<<} operation can be replaced (overloaded) for other types.}
\RU{Что и делается в}\EN{That is what is done in} ostream.
\RU{Видно, что в реальности вызывается \TT{operator<<} для ostream}\EN{We see that \TT{operator<<} is called for ostream}:

\lstinputlisting[caption=MSVC 2012 (reduced listing)]{\CURPATH/ostream/1.asm}

\RU{Немного переделаем пример}\EN{Let's modify the example}:

\lstinputlisting{\CURPATH/ostream/2.cpp}

\RU{И снова, из многих учебников по \Cpp, известно, что результат каждого \TT{operator<<} 
в ostream передается в следующий.}
\EN{And again, from many \Cpp textbooks we know that the result of each \TT{operator<<} in ostream is forwarded to the
next one.}
\RU{Действительно}\EN{Indeed}:

\lstinputlisting[caption=MSVC 2012]{\CURPATH/ostream/2.asm.\LANG}

\RU{Если переименовать название метода \TT{operator<<} в \ttf{}, то этот код выглядел бы так:}
\EN{If we would rename \TT{operator<<} method name to \ttf{}, that code will looks like:}

\begin{lstlisting}
f(f(std::cout, "Hello, "), "world!");
\end{lstlisting}

GCC \RU{генерирует практически такой же код как и}\EN{generates almost the same code as} MSVC.

