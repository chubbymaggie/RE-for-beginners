\subsection{\RU{Наследование классов}\EN{Class inheritance}}

\RU{О наследованных классах можно сказать, что это та же простая структура, которую мы уже рассмотрели, 
только расширяемая в наследуемых классах.}
\EN{Inherited classes are similar to the simple structures we already discussed, but extended 
in inheritable classes.}

\RU{Возьмем очень простой пример}\EN{Let's take this simple example}:

\lstinputlisting{\CURPATH/classes/classes1_inheritance.cpp}

\RU{Исследуя сгенерированный код для функций/методов \TT{dump()}, а также \TT{object::print\_color()},
посмотрим, какая будет разметка памяти для структур-объектов (для 32-битного кода).}
\EN{Let's investigate the generated code of the \TT{dump()} functions/methods and also \TT{object::print\_color()},
and see the memory layout for the structures-objects (for 32-bit code).}

\index{Inline code}
\RU{Итак, методы \TT{dump()} разных классов сгенерированные MSVC 2008 с опциями \Ox и \Obzero}
\EN{So, here are the \TT{dump()} methods for several classes, generated by MSVC 2008 with \Ox and \Obzero options}
\footnote{\RU{опция \Obzero означает отмену inline expansion, 
ведь вставка компилятором тела функции/метода прямо в код где он вызывается, 
может затруднить наши эксперименты}
\EN{The \Obzero option stands for disabling inline expansion since function inlining
can make our experiment harder}}

\lstinputlisting[caption=\Optimizing MSVC 2008 /Ob0]{\CURPATH/classes/classes1_1.asm}

\lstinputlisting[caption=\Optimizing MSVC 2008 /Ob0]{\CURPATH/classes/classes1_2.asm}

\lstinputlisting[caption=\Optimizing MSVC 2008 /Ob0]{\CURPATH/classes/classes1_3.asm}

\RU{Итак, разметка полей получается следующая}\EN{So, here is the memory layout}:

\RU{(базовый класс \IT{object})}\EN{(base class \IT{object})}

\begin{center}
\begin{tabular}{ | l | l | }
\hline
  \tableheader{} \\
\hline
  +0x0 & int color \\
\hline
\end{tabular}
\end{center}

\RU{(унаследованные классы)}\EN{(inherited classes)}

\IT{box}:

\begin{center}
\begin{tabular}{ | l | l | }
\hline
  \tableheader{} \\
\hline
  +0x0 & int color \\
\hline
  +0x4 & int width \\
\hline
  +0x8 & int height \\
\hline
  +0xC & int depth \\
\hline
\end{tabular}
\end{center}

\IT{sphere}:

\begin{center}
\begin{tabular}{ | l | l | }
\hline
  \tableheader{} \\
\hline
  +0x0 & int color \\
\hline
  +0x4 & int radius \\
\hline
\end{tabular}
\end{center}

\RU{Посмотрим тело \main}\EN{Let's see \main function body}:

\lstinputlisting[caption=\Optimizing MSVC 2008 /Ob0]{\CURPATH/classes/classes1_4.asm}

\RU{Наследованные классы всегда должны добавлять свои поля после полей базового класса для того, чтобы методы
базового класса могли продолжать работать со своими собственными полями.}
\EN{The inherited classes must always add their fields after the base classes' fields, to make it possible for the base 
class methods to work with their own fields.}

\RU{Когда метод \TT{object::print\_color()} вызывается, ему в качестве \TT{this} передается указатель и на объект типа \IT{box} 
и на объект типа \IT{sphere}, так как он может легко работать с классами \IT{box} и \IT{sphere}, потому что поле \IT{color} в этих
классах всегда стоит по тому же адресу (по смещению \TT{0x0}).}
\EN{When the \TT{object::print\_color()} method is called, a pointers to both the \IT{box} and \IT{sphere} objects are passed as \TT{this},
and it can work with these objects easily since the \IT{color} field in these objects is always at the pinned address (at offset \IT{+0x0}).}

\RU{Можно также сказать, что методу \TT{object::print\_color()} даже не нужно знать,
с каким классом он работает, до тех пор, пока будет соблюдаться условие \IT{закрепления} полей по тем же адресам,
а это условие соблюдается всегда.}
\EN{It can be said that the \TT{object::print\_color()} method is agnostic in relation to the input object type as long as the fields are \IT{pinned}
at the same addresses, and this condition is always true.}

\RU{А если вы создадите класс-наследник класса \IT{box}, например, 
то компилятор будет добавлять новые поля уже за полем \IT{depth}, оставляя уже имеющиеся поля класса \IT{box} по тем же адресам.}
\EN{And if you create inherited class of the \IT{box} class, 
the compiler will add the new fields after the \IT{depth} field,
leaving the \IT{box} class fields at the pinned addresses.}

\RU{Так, метод \TT{box::dump()} будет нормально работать обращаясь к полям 
\IT{color}/\IT{width}/\IT{height}/\IT{depth} всегда находящимся по известным адресам.}
\EN{Thus, the \TT{box::dump()} method will work fine for accessing the 
\IT{color}/\IT{width}/\IT{height}/\IT{depths} fields, which are always pinned at known addresses.}

\RU{Код на GCC практически точно такой же, за исключением способа передачи \TT{this} (он, как уже было указано, 
передается в первом аргументе, вместо регистра \ECX).}
\EN{The code generated by GCC is almost the same, with the sole exception of passing the \TT{this} pointer (as it was explained above,
it is passed as the first argument instead of using the \ECX register.}

