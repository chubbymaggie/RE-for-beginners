\subsection{std::string}
\index{\Cpp!STL!std::string}
\label{std_string}

\subsubsection{\RU{Как устроена структура}\EN{Internals}}

\RU{Многие строковые библиотеки \cite[2.2]{CBook} обеспечивают структуру содержащую ссылку 
на буфер собственно со строкой, переменная всегда содержащую длину строки 
(что очень удобно для массы функций \cite[2.2.1]{CBook}) и переменную содержащую текущий размер буфера.}
\EN{Many string libraries \cite[2.2]{CBook} implement a structure that contains a pointer to a string buffer,
a variable that always contains the current string length 
(which is very convenient for many functions: \cite[2.2.1]{CBook}) and
a variable containing the current buffer size.}
\RU{Строка в буфере обыкновенно оканчивается нулем: это для того чтобы указатель на буфер можно было
передавать в функции требующие на вход обычную сишную \ac{ASCIIZ}-строку.}
\EN{The string in the buffer is usually terminated with zero, in order to be able to pass a pointer to the buffer
into the functions that take  usual C \ac{ASCIIZ} strings.}

\RU{Стандарт \Cpp \cite{CPP11} не описывает, как именно нужно реализовывать std::string,
но как правило они реализованы как описано выше, с небольшими дополнениями}
\EN{It is not specified in the \Cpp standard \cite{CPP11} how std::string has to be implemented,
however, it is usually implemented as explained above}.

\RU{Строки в \Cpp это не класс (как, например, QString в Qt), а темплейт (basic\_string), 
это сделано для того чтобы поддерживать 
строки содержащие разного типа символы: как минимум \Tchar и \IT{wchar\_t}.}
\EN{The \Cpp string is not a class (as QString in Qt, for instance) but a template (basic\_string),
this is done in order to support various character types: at least \Tchar and \IT{wchar\_t}.}

\RU{Так что, std::string это класс с базовым типом \Tchar.}
\EN{So, std::string is a class with \Tchar as its base type.}
\RU{А std::wstring это класс с базовым типом \IT{wchar\_t}.}
\EN{And std::wstring is a class with \IT{wchar\_t} as its base type.}

\myparagraph{MSVC}

\RU{В реализации MSVC, вместо ссылки на буфер может содержаться сам буфер (если строка короче 16-и символов).}
\EN{The MSVC implementation may store the buffer in place instead of using a pointer to a buffer 
(if the string is shorter than 16 symbols).}

\RU{Это означает что каждая короткая строка будет занимать в памяти по крайней мере}
\EN{This implies that a short string is to occupy at least} $16 + 4 + 4 = 24$ 
\RU{байт для 32-битной среды либо}\EN{bytes in 32-bit environment or at least} $16 + 8 + 8 = 32$ 
\RU{байта в 64-битной, а если строка длиннее 16-и символов, то прибавьте еще длину самой строки}
\EN{bytes in 64-bit one, and if the string is longer than 16 characters, we also have to add the length of the string itself}.

\lstinputlisting[caption=\RU{пример для}\EN{example for} MSVC]{\CURPATH/STL/string/MSVC.cpp.\LANG}

\RU{Собственно, из этого исходника почти всё ясно.}\EN{Almost everything is clear from the source code.}

\RU{Несколько замечаний}\EN{A couple of notes}:

\RU{Если строка короче 16-и символов, 
то отдельный буфер для строки в \glslink{heap}{куче} выделяться не будет.}
\EN{If the string is shorter than 16 symbols, 
a buffer for the string is not to be allocated in the \gls{heap}.}
\RU{Это удобно потому что на практике, действительно немало строк короткие}
\EN{This is convenient because
in practice, a lot of strings are short indeed}.
\RU{Вероятно, разработчики в Microsoft выбрали размер в 16 символов как разумный баланс}
\EN{Looks like that Microsoft's developers chose 16 characters as a good balance}.

\RU{Теперь очень важный момент в конце функции main(): мы не пользуемся методом c\_str(), тем не менее,
если это скомпилировать и запустить, то обе строки появятся в консоли!}%
\EN{One very important thing here can be seen at the end of main(): we're not using the c\_str() method, nevertheless,
if we compile and run this code, both strings will appear in the console!}

\RU{Работает это вот почему}\EN{This is why it works}.

\RU{В первом случае строка короче 16-и символов и в начале объекта std::string (его можно рассматривать
просто как структуру) расположен буфер с этой строкой}
\EN{In the first case the string is shorter than 16 characters and the buffer with the string is located in the
beginning of the std::string object (it can be treated as a structure)}.
printf() \RU{трактует указатель как указатель на массив
символов оканчивающийся нулем и поэтому всё работает}\EN{treats the pointer as a pointer to the null-terminated 
array of characters, hence it works}.

\RU{Вывод второй строки (длиннее 16-и символов) даже еще опаснее: это вообще типичная программистская ошибка 
(или опечатка), забыть дописать c\_str()}
\EN{Printing the second string (longer than 16 characters) is even more dangerous: it is a typical programmer's mistake
(or typo) to forget to write c\_str()}.
\RU{Это работает потому что в это время в начале структуры расположен указатель на буфер}
\EN{This works because at the moment a pointer to buffer is located at the start of structure}.
\RU{Это может надолго остаться незамеченным: до тех пока там не появится строка 
короче 16-и символов, тогда процесс упадет.}
\EN{This may stay unnoticed for a long time, until a longer string appears there at some time, 
then the process will crash.}

\myparagraph{GCC}

\RU{В реализации GCC в структуре есть еще одна переменная\EMDASH{}reference count}
\EN{GCC's implementation of this structure has one more variable\EMDASH{}reference count}.

\RU{Интересно, что указатель на экземпляр класса std::string в GCC указывает не на начало самой структуры, 
а на указатель на буфера}\EN{One interesting fact is that in GCC a pointer an instance of std::string instance points not to
the beginning of the structure, but to the buffer pointer}.
\RU{В}\EN{In} libstdc++-v3\textbackslash{}include\textbackslash{}bits\textbackslash{}basic\_string.h 
\RU{мы можем прочитать что это сделано для удобства отладки}
\EN{we can read that it was done for more convenient debugging}:

\begin{lstlisting}
   *  The reason you want _M_data pointing to the character %array and
   *  not the _Rep is so that the debugger can see the string
   *  contents. (Probably we should add a non-inline member to get
   *  the _Rep for the debugger to use, so users can check the actual
   *  string length.)
\end{lstlisting}

\href{http://go.yurichev.com/17085}
{\RU{исходный код }basic\_string.h\EN{ source code}}

\RU{В нашем примере мы учитываем это}\EN{We consider this in our example}:

\lstinputlisting[caption=\RU{пример для}\EN{example for} GCC]{\CURPATH/STL/string/GCC.cpp.\LANG}

\RU{Нужны еще небольшие хаки чтобы сымитировать типичную ошибку, которую мы уже видели выше, из-за
более ужесточенной проверки типов в GCC, тем не менее, printf() работает и здесь без c\_str()}
\EN{A trickery has to be used to imitate the mistake we already have seen above because GCC
has stronger type checking, nevertheless, printf() works here without c\_str() as well}.

\subsubsection{\RU{Чуть более сложный пример}\EN{A more complex example}}

\lstinputlisting{\CURPATH/STL/string/3.cpp}

\lstinputlisting[caption=MSVC 2012]{\CURPATH/STL/string/3_MSVC.asm.\LANG}

\RU{Собственно, компилятор не конструирует строки статически: да в общем-то и как
это возможно, если буфер с ней нужно хранить в \glslink{heap}{куче}?}
\EN{The compiler does not construct strings statically: it would not be possible anyway if the buffer needs to be located
in the \gls{heap}.}
\RU{Вместо этого в сегменте данных хранятся обычные \ac{ASCIIZ}-строки, а позже, во время выполнения, 
при помощи метода \q{assign}, конструируются строки s1 и s2}
\EN{Instead, the \ac{ASCIIZ} strings are stored in the data segment, and later, at runtime,
with the help of the \q{assign} method, the s1 and s2 strings are constructed}.
\RU{При помощи \TT{operator+}, создается строка s3}\EN{And with the help of \TT{operator+}, the s3 string is constructed}.

\RU{Обратите внимание на то что вызов метода c\_str() отсутствует,
потому что его код достаточно короткий и компилятор вставил его прямо здесь:
если строка короче 16-и байт, то в регистре EAX остается указатель на буфер,
а если длиннее, то из этого же места достается адрес на буфер расположенный в \glslink{heap}{куче}}
\EN{Please note that 
there is no call to the c\_str() method, because its code is tiny enough so the compiler
inlined it right there: if the string is shorter than 16 characters, a pointer to buffer is left
in \EAX, otherwise the address of the string buffer located in the \gls{heap} is fetched}.

\RU{Далее следуют вызовы трех деструкторов, причем, они вызываются только если строка длиннее 16-и байт:
тогда нужно освободить буфера в \glslink{heap}{куче}}\EN{Next, we see calls to the 3 destructors, they are called if
the string is longer than 16 characters: then the buffers in the \gls{heap} have to be freed}.
\RU{В противном случае, так как все три объекта std::string хранятся в стеке,
они освобождаются автоматически после выхода из функции}\EN{Otherwise, since all three std::string objects
are stored in the stack, they are freed automatically, when the function ends}.

\RU{Следовательно, работа с короткими строками более быстрая из-за м\'{е}ньшего обращения к \glslink{heap}{куче}}
\EN{As a consequence, processing short strings is faster, because of less \gls{heap} accesses}.

\RU{Код на GCC даже проще (из-за того, что в GCC, как мы уже видели, не реализована возможность хранить короткую
строку прямо в структуре)}\EN{GCC code is even simpler (because the GCC way, as we saw above, is to not store
shorter strings right in the structure)}:

% TODO1 comment each function meaning
\lstinputlisting[caption=GCC 4.8.1]{\CURPATH/STL/string/3_GCC.s.\LANG}

\RU{Можно заметить, что в деструкторы передается не указатель на объект,
а указатель на место за 12 байт (или 3 слова) перед ним, то есть, на настоящее начало структуры}
\EN{It can be seen that it's not a pointer to the object that is passed to destructors, but rather an address 12 bytes (or 3 words)
before, i.e., a pointer to the real start of the structure}.

\subsubsection{std::string \RU{как глобальная переменная}\EN{as a global variable}}
\label{sec:std_string_as_global_variable}

\RU{Опытные программисты на \Cpp знают что глобальные переменные \ac{STL}-типов вполне можно объявлять.}
\EN{Experienced \Cpp programmers knows that global variables of \ac{STL} types can be defined without problems.}

\RU{Да, действительно}\EN{Yes, indeed}:

\lstinputlisting{\CURPATH/STL/string/5.cpp}

\EN{But how and where \TT{std::string} constructor will be called?}
\RU{Но как и где будет вызываться конструктор \TT{std::string}?}

\RU{На самом деле, эта переменная будет инициализирована даже перед началом \main.}
\EN{In fact, this variable is to be initialized even before \main start.}

\lstinputlisting[caption=MSVC 2012: \RU{здесь конструируется глобальная переменная, а также регистрируется её деструктор}\EN{here is how a global variable is constructed and also its destructor is registered}]{\CURPATH/STL/string/5_MSVC_p2.asm}

\lstinputlisting[caption=MSVC 2012: 
\RU{здесь глобальная переменная используется в}\EN{here a global variable is used in} \main]{\CURPATH/STL/string/5_MSVC_p1.asm}

\lstinputlisting[caption=MSVC 2012: \RU{эта функция-деструктор вызывается перед выходом}
\EN{this destructor function is called before exit}]{\CURPATH/STL/string/5_MSVC_p3.asm}

\index{\CStandardLibrary!atexit()}
\RU{В реальности, из \ac{CRT}, еще до вызова main(), вызывается специальная функция,
в которой перечислены все конструкторы подобных переменных}
\EN{In fact, a special function with all constructors of global variables is called from \ac{CRT}, before
main()}.
\RU{Более того: при помощи atexit() регистрируется функция, которая будет вызвана в конце работы программы:
в этой функции компилятор собирает вызовы деструкторов всех подобных глобальных переменных.}
\EN{More than that: with the help of atexit() another function is registered, 
which contain calls to all destructors of such global variables.}

GCC \RU{работает похожим образом}\EN{works likewise}:

\lstinputlisting[caption=GCC 4.8.1]{\CURPATH/STL/string/5_GCC.s}

\RU{Но он не выделяет отдельной функции в которой будут собраны деструкторы: 
каждый деструктор передается в atexit() по одному.}
\EN{But it does not create a separate function for this, 
each destructor is passed to atexit(), one by one.}

% TODO а если глобальная STL-переменная в другом модуле? надо проверить.

