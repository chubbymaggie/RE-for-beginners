\chapter{\RU{Inline-функции}\EN{Inline functions}}
\index{Inline code}
\label{inline_code}

\RU{Inline-код это когда компилятор, вместо того чтобы генерировать инструкцию вызова небольшой функции,
просто вставляет её тело прямо в это место.}
\EN{Inlined code is when the compiler, instead of placing a call instruction to a small or tiny function,
just places its body right in-place.}

\lstinputlisting[caption=\RU{Простой пример}\EN{A simple example}]{\CURPATH/1.c}

\dots 
\RU{это компилируется вполне предсказуемо, хотя, если включить оптимизации GCC (\Othree), мы увидим:}
\EN{is compiled in very predictable way, however, if we turn on GCC optimizations (\Othree), we'll see:}

\lstinputlisting[caption=\Optimizing GCC 4.8.1]{\CURPATH/1.s}

(\RU{Здесь деление заменено умножением}\EN{Here the division is done by multiplication}(\myref{sec:divisionbynine}).)

\RU{Да, наша маленькая функция \TT{celsius\_to\_fahrenheit()} была помещена прямо перед вызовом \printf.}
\EN{Yes, our small function \TT{celsius\_to\_fahrenheit()} was just placed before the \printf call.}
\RU{Почему? Это может быть быстрее чем исполнять код самой функции плюс затраты на вызов и возврат.}
\EN{Why? It can be faster than executing this function's code plus the overhead of calling/returning.}

\RU{Современные оптимизирующие компиляторы самостоятельно выбирают функции для вставки.
Но компилятор можно дополнительно принудить развернуть некоторую функцию, 
если маркировать её ключевым словом \q{inline} в её определении.}
\EN{Modern optimizing compilers are choosing small functions for inlining automatically.
But it's possible to force compiler additionally to inline some function, if to mark
it with the \q{inline} keyword in its declaration.}

% sections
\input{\CURPATH/str_mem/main}
