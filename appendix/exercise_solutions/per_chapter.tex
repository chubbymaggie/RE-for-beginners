\section{\RU{По главам}\EN{Per chapter}}

\subsection{\RU{Глава \q{\HelloWorldSectionName}}\EN{\q{\HelloWorldSectionName} chapter}}

\subsubsection{\Exercise \#1}
\label{exercise_solutions_hw_1}

\Exercise: \myref{exercise_hw_1}.

\begin{lstlisting}
MessageBeep (0xFFFFFFFF); // A simple beep. If the sound card is not available, the sound is generated using the speaker.
\end{lstlisting}

\subsubsection{\Exercise \#2}
\label{exercise_solutions_hw_2}

\Exercise: \myref{exercise_hw_2}.

\begin{lstlisting}
#include <unistd.h>

int main()
{
        sleep(2);
};
\end{lstlisting}

\subsection{\RU{Глава \q{\Stack}}\EN{\q{\Stack} chapter}}
%02..

\subsubsection{\Exercise \#1}
\label{exercise_solutions_stack_1}

\Exercise: \myref{exercise_stack_1}.

\EN{In \NonOptimizing MSVC, these numbers are: the saved \EBP value}\RU{Если MSVC без оптимизации, 
то эти числа таковы: сохраненное значение \EBP}, \ac{RA} \AndENRU \TT{argc}.
\RU{В этом легко убедиться, если запускать пример с разным количеством аргументов в командной 
строке}\EN{It's easy to check that by running the example with a different number
of arguments on the command line}.

\RU{Если MSVC с оптимизацией, то числа таковы}\EN{In \Optimizing MSVC, these numbers are}: 
\ac{RA}, \TT{argc} \RU{и указатель на массив}\EN{and a pointer to the} \TT{argv[]}\EN{ array}.

GCC 4.8.x \RU{выделяет в прологе функции \main 16-байтное пространство, поэтому числа на 
выходе совсем другие}\EN{allocates 16-byte space in \main function's prologue, 
hence the different output numbers}.

\subsubsection{\Exercise \#2}
\label{exercise_solutions_stack_2}

\Exercise: \myref{exercise_stack_2}.

\RU{Этот код выводит время в формате UNIX}\EN{This code prints the UNIX time}.

\begin{lstlisting}
#include <stdio.h>
#include <time.h>

int main()
{
	printf ("%d\n", time(NULL));
};
\end{lstlisting}

\subsection{\RU{Глава \q{scanf()}}\EN{\q{scanf()} chapter}}

\subsubsection{\Exercise \#1}
\label{exercise_solutions_scanf_1}

\Exercise: \myref{exercise_scanf_1}.

\EN{GCC for Linux places all text strings info \TT{.rodata} data segment, which is explicitly read-only}
\RU{GCC для Linux размещает все текстовые строки в сегменте \TT{.rodata}, который явно только для чтения} (``read only data''):

\begin{lstlisting}
$ objdump -s 1

...

Contents of section .rodata:
 400600 01000200 52657375 6c743a20 25730a00  ....Result: %s..
 400610 48656c6c 6f2c2077 6f726c64 210a00    Hello, world!.. 
\end{lstlisting}

\EN{When \TT{alter\_string()} function tries to write there, exception occurred.}
\RU{Когда функция \TT{alter\_string()} пытается записать туда что-то, происходит исключение.}

\EN{Things are different in the code generated by MSVC, strings are located in \TT{.data} segment, which has no \TT{READONLY} flag:}
\RU{Всё немного иначе в коде созданном MSVC, строки размещаются в сегменте \TT{.data}, который не имеет флага \TT{READONLY}:}

\begin{lstlisting}
C:\...>objdump -s 1.exe 

...

Contents of section .data:
 40b000 476f6f64 62796521 00000000 52657375  Goodbye!....Resu
 40b010 6c743a20 25730a00 48656c6c 6f2c2077  lt: %s..Hello, w
 40b020 6f726c64 210a0000 00000000 00000000  orld!...........
 40b030 01000000 00000000 c0cb4000 00000000  ..........@.....

...

C:\...>objdump -x 1.exe 

...

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006d2a  00401000  00401000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rdata        00002262  00408000  00408000  00007200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .data         00000e00  0040b000  0040b000  00009600  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .reloc        00000b98  0040e000  0040e000  0000a400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
\end{lstlisting}

\subsection{\RU{Глава \q{\SwitchCaseDefaultSectionName}}\EN{\q{\SwitchCaseDefaultSectionName} chapter}}
%08...

\subsection{\Exercise \#1}
\label{exercise_solutions_switch_1}

\Exercise: \myref{exercise_switch_1}.

\RU{Подсказка}\EN{Hint}: \printf \EN{may be called only from a single place}\RU{вполне может 
вызываться только из одного места}.

\subsection{\RU{Глава \q{\Loops}}\EN{\q{\Loops} chapter}}
%09...

\subsection{\Exercise \#3}
\label{exercise_solutions_loops_3}

\Exercise: \myref{exercise_loops_3}.

\begin{lstlisting}
#include <stdio.h>

int main()
{
	int i;
	for (i=100; i>0; i--)
		printf ("%d\n", i);
};
\end{lstlisting}

\subsection{\Exercise \#4}
\label{exercise_solutions_loops_4}

\Exercise: \myref{exercise_loops_4}.

\begin{lstlisting}
#include <stdio.h>

int main()
{
	int i;
	for (i=1; i<100; i=i+3)
		printf ("%d\n", i);
};
\end{lstlisting}

\subsection{\RU{Глава \q{\SimpleStringsProcessings}}\EN{\q{\SimpleStringsProcessings} chapter}}
%10..

\subsubsection{\Exercise \#1}
\label{exercise_solutions_strlen_1}

\Exercise: \myref{exercise_strlen_1}.

\RU{Эта функция подсчитывает пробелы во входящей Си-строке.}
\EN{This is a function that counts spaces in the input C string.}

\begin{lstlisting}
int f(char *s)
{
	int rt=0;
	for (;*s;s++)
	{
		if (*s==' ')
			rt++;
	};
	return rt;
};
\end{lstlisting}

\subsection{\RU{Глава \q{\ArithOptimizations}}\EN{\q{\ArithOptimizations} chapter}}
%11..

\subsubsection{\Exercise \#2}
\label{exercise_solutions_arith_optimizations_2}

\Exercise: \myref{exercise_arith_optimizations_2}.

\begin{lstlisting}
int f(int a)
{
	return a*7;
};
\end{lstlisting}

\subsection{\RU{Глава \q{\FPUChapterName}}\EN{\q{\FPUChapterName} chapter}}
%12..

\subsubsection{\Exercise \#1}
\label{exercise_solutions_FPU_2}

\Exercise: \myref{exercise_FPU_2}.

\EN{Calculates the arithmetic mean for 5 \Tdouble values.}
\RU{Вычисление среднего арифметического для пяти значений типа \Tdouble.}

\begin{lstlisting}
double f(double a1, double a2, double a3, double a4, double a5)
{
	return (a1+a2+a3+a4+a5) / 5;
};
\end{lstlisting}

\subsection{\RU{Глава \q{\Arrays}}\EN{\q{\Arrays} chapter}}
%13..

\subsubsection{\Exercise \#1}
\label{exercise_solutions_arrays_1}

\Exercise: \myref{exercise_array_1}.

% TODO: make example of it!
\RU{Ответ: сложение двух матриц размером 100 на 200 элементов типа \Tdouble.}
\EN{Solution: addition of two 100*200 matrices of type \Tdouble.}

\RU{Исходник на \CCpp}\EN{\CCpp source code}:

\begin{lstlisting}
#define M    100
#define N    200

void s(double *a, double *b, double *c)
{
  for(int i=0;i<N;i++)
    for(int j=0;j<M;j++)
      *(c+i*M+j)=*(a+i*M+j) + *(b+i*M+j);
};
\end{lstlisting}

\subsubsection{\Exercise \#2}
\label{exercise_solutions_arrays_2}

\Exercise: \myref{exercise_array_2}.

% TODO: make example of it?
\RU{Ответ: умножение двух матриц размерами 100*200 и 100*300 элементов типа \Tdouble, результат: матрица 100*300.}
\EN{Solution: multiplication of two matrices (one is 100*200, second is 100*300) of type \Tdouble, result: 100*300
matrix.}

\RU{Исходник на \CCpp}\EN{\CCpp source code}:

\begin{lstlisting}
#define M     100
#define N     200
#define P     300

void m(double *a, double *b, double *c)
{
  for(int i=0;i<M;i++)
    for(int j=0;j<P;j++)
    {
      *(c+i*M+j)=0;
      for (int k=0;k<N;k++) *(c+i*M+j)+=*(a+i*M+j) * *(b+i*M+j);
    }
};
\end{lstlisting}

\subsubsection{\Exercise \#3}
\label{exercise_solutions_arrays_3}

\Exercise: \myref{exercise_array_3}.

\begin{lstlisting}
double f(double array[50][120], int x, int y)
{
	return array[x][y];
};
\end{lstlisting}

\subsubsection{\Exercise \#4}
\label{exercise_solutions_arrays_4}

\Exercise: \myref{exercise_array_4}.

\begin{lstlisting}
int f(int array[50][60][80], int x, int y, int z)
{
	return array[x][y][z];
};
\end{lstlisting}

\subsubsection{\Exercise \#5}
\label{exercise_solutions_arrays_5}

\Exercise: \myref{exercise_array_5}.

\EN{This code just calculates the multiplication table.}
\RU{Этот код просто вычисляет таблицу умножения.}

\begin{lstlisting}
int tbl[10][10];

int main()
{
	int x, y;
	for (x=0; x<10; x++)
		for (y=0; y<10; y++)
			tbl[x][y]=x*y;
};
\end{lstlisting}

% TODO MSVC 2012 optimizations!

\subsection{\RU{Глава \q{\BitfieldsChapter}}\EN{\q{\BitfieldsChapter} chapter}}
%14..

\subsubsection{\Exercise \#1}
\label{exercise_solutions_bitfields_1}

\Exercise: \myref{exercise_bitfields_1}.
% TODO: make example of it!
\RU{Эта функция меняет}\EN{This is a function, which changes the} \gls{endianness} 
\RU{в 32-битном значении}\EN{of a 32-bit value}.

\lstinputlisting{appendix/exercise_solutions/change_endiannes.c}

\RU{Дополнительный вопрос: в x86 есть инструкция, делающая всё это. Какая?}\EN{Additional question: a x86 
instruction can do this. Which one?}
% answer: BSWAP

\subsubsection{\Exercise \#2}
\label{exercise_solutions_bitfields_2}

\Exercise: \myref{exercise_bitfields_2}.

\RU{Эта функция конвертирует значение, запакованное в формате \ac{BCD} в обычное.}
\EN{This function converts a \ac{BCD}-packed 32-bit value into a normal one.}

\begin{lstlisting}
#include <stdio.h>

unsigned int f(unsigned int a)
{
	int i=0;
	int j=1;
	unsigned int rt=0;
	for (;i<=28; i+=4, j*=10)
		rt+=((a>>i)&0xF) * j;
	return rt;
};

int main()
{
	// test
	printf ("%d\n", f(0x12345678));
	printf ("%d\n", f(0x1234567));
	printf ("%d\n", f(0x123456));
	printf ("%d\n", f(0x12345));
	printf ("%d\n", f(0x1234));
	printf ("%d\n", f(0x123));
	printf ("%d\n", f(0x12));
	printf ("%d\n", f(0x1));
};
\end{lstlisting}

\subsubsection{\Exercise \#3}
\label{exercise_solutions_bitfields_3}

\Exercise: \myref{exercise_bitfields_3}.

\begin{lstlisting}
#include <windows.h>

int main()
{
	MessageBox(NULL, "hello, world!", "caption", 
		MB_TOPMOST | MB_ICONINFORMATION | MB_HELP | MB_YESNOCANCEL);
};
\end{lstlisting}

\subsubsection{\Exercise \#4}
\label{exercise_solutions_bitfields_4}

\Exercise: \myref{exercise_bitfields_4}.

\EN{This function just multiplies two 32-bit numbers, returning a 64-bit \gls{product}.}
\RU{Эта функция просто перемножает два 32-битных числа, возвращая 64-битное \glslink{product}{произведение}.}
\EN{This is a case when the simple observation of inputs and outputs may solve the problem faster.}
\RU{Да, это тот случай, когда простое наблюдение входных и выходных значений может решить проблему быстрее.}

% FIXME1: russian listing
\begin{lstlisting}
#include <stdio.h>
#include <stdint.h>

// source code taken from
// http://www4.wittenberg.edu/academics/mathcomp/shelburne/comp255/notes/binarymultiplication.pdf

uint64_t mult (uint32_t m, uint32_t n)
{
    uint64_t p = 0; // initialize product p to 0 
    while (n != 0) // while multiplier n is not 0 
    { 
        if (n & 1) // test LSB of multiplier 
            p = p + m; // if 1 then add multiplicand m 
        m = m << 1; // left shift multiplicand 
        n = n >> 1; // right shift multiplier 
    }
    return p;
}

int main()
{
    printf ("%d\n", mult (2, 7));
    printf ("%d\n", mult (3, 11));
    printf ("%d\n", mult (4, 111));
};
\end{lstlisting}

\subsection{\RU{Глава \q{\StructuresChapterName}}\EN{\q{\StructuresChapterName} chapter}}
%15..

\subsubsection{\Exercise \#1}
\label{exercise_solutions_struct_1}

\Exercise: \myref{exercise_struct_1}.

\RU{Эта программа показывает ID пользователя, владеющего файлом}\EN{This program shows the user ID of the file's owner}.

\begin{lstlisting}
#include <sys/types.h>
#include <sys/stat.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
    struct stat sb;

    if (argc != 2) 
    {
        fprintf(stderr, "Usage: %s <pathname>\n", argv[0]);
        return 0;
    }

    if (stat(argv[1], &sb) == -1) 
    {
    	// error
        return 0;
    }

    printf("%ld\n",(long) sb.st_uid);
}
\end{lstlisting}

\subsubsection{\Exercise \#1}
\label{exercise_solutions_struct_2}

\Exercise: \myref{exercise_struct_2}.

\EN{Hint (x86): you may get some information from how the values are treated by the \TT{Jcc}, \MOVSX and \MOVZX instructions.}
\RU{Подсказка (x86): вы можете получить какую-то информацию глядя на то как значения обрабатываются при помощи
инструкций \TT{Jcc}, \MOVSX и \MOVZX.}

\begin{lstlisting}
#include <stdio.h>

struct some_struct
{
	int a;
	unsigned int b;
	float f;
	double d;
	char c;
	unsigned char uc;
};

void f(struct some_struct *s)
{
	if (s->a > 1000)
	{
		if (s->b > 10)
		{
			printf ("%f\n", s->f * 444 + s->d * 123);
			printf ("%c, %d\n", s->c, s->uc);
		}
		else
		{
			printf ("error #2\n");
		};
	}
	else
	{
		printf ("error #1\n");
	};
};
\end{lstlisting}

\subsection{\RU{Глава \q{Обфускация}}\EN{\q{Obfuscation} chapter}}

\subsubsection{\Exercise \#1}
\label{exercise_solutions_obfuscation_1}

\Exercise: \myref{exercise_obfuscation_1}.

\RU{Исходный код}\EN{Source code}: \href{http://go.yurichev.com/17162}{beginners.re}.

\subsection{\RU{Глава \q{\DivisionByNineSectionName}}\EN{\q{\DivisionByNineSectionName} chapter}}

\subsubsection{\Exercise \#1}
\label{exercise_solutions_arith_optimizations_1}

\Exercise: \myref{exercise_arith_optimizations_1}.

\begin{lstlisting}
int f(int a)
{
	return a/661;
};
\end{lstlisting}
